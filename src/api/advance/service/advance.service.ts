import { Injectable } from '@nestjs/common';
import { BasicCrudService } from '../../../commons/services/crud.service';
import { InjectRepository } from '@nestjs/typeorm';
import { IsNull, Repository } from 'typeorm';
import { Advance } from '../entity/advance.entity';
import { AdvanceDTO } from '../entity/advance.dto';
import { Employee } from 'src/api/employee/entity/employee.entity'
import { AdvanceState } from 'src/api/advance_state/entity/advance_state.entity'
import { EmployeeService } from 'src/api/employee/service/employee.service';
import { AdvancePeriod } from 'src/api/advance_period/entity/advance_period.entity';

@Injectable()
export class AdvanceService extends BasicCrudService<Advance, string, AdvanceDTO>{

    constructor(
        @InjectRepository(Advance)
        protected repo: Repository<Advance>,
        protected employeeService: EmployeeService,
    ) {super();}

    findAll(): Promise<Advance[]> {
        return this.findMany({ 
            order: { created_date: 'DESC' }, 
            relations: { employee: { range: true } }
        });
    }

    findAllByPeriod(period: string): Promise<Advance[]> {
        return this.findMany({ 
            where: {period: {uuid: period}},
            order: { created_date: 'DESC' }, 
            relations: { employee: { range: true } }
        });
    }

    findById(id: string): Promise<Advance>{
        try{
            return this.findOne({where: {uuid:id}});
        } catch(err){
            throw new Error(err.message);
        }
    }

    buildBaseCreation(dto: AdvanceDTO): Advance{
        //Validations data
        if(! dto) throw new Error('DTO empty');

        //Assign data
        let entity = new Advance();
        entity.created_date = new Date();
        entity.approved_date = null;
        entity.declined_date = null;
        entity.value = dto.value;
        entity.cost = dto.cost;
        entity.use_fintech = dto.use_fintech;
        let employee = new Employee();
        employee.uuid = dto.employee;
        entity.employee = employee;
        let advance_state = new AdvanceState();
        advance_state.cod = dto.state;
        entity.state = advance_state;
        if(! dto.period) throw new Error('No period in DTO');
        let period = new AdvancePeriod();
        period.uuid = dto.period;
        entity.period = period;
        return entity;
    }

    async dataValidationBeforeCreate(dto: AdvanceDTO): Promise<void> {
        const employee = await this.employeeService.findById(dto.employee);
        if(employee === null) throw new Error(`Employee not found to create advance`);
        if(employee.state === 0 || employee.state === -1) throw new Error(`Los anticipos estÃ¡n inactivos temporalmente`);
        const advances = await this.findAllByEmployeePending(dto.employee);
        if(advances.length > 0) throw new Error(`Tienes almenos un anticipo pendiente`);
        const period = await this.repo.manager.getRepository(AdvancePeriod)
            .findOne({ where: {enterprise_id: employee.range?.enterprise?.id, finished_date: IsNull()} });
        if(! period) throw new Error(`No hay periodo de avances abierto`);

        dto.period = period.uuid;
    }

    buildBaseEdition(entity: Advance, dto: AdvanceDTO): Advance{
        //Validations data
        if(! dto) throw new Error('DTO empty');
        if(! dto.uuid) throw new Error('Entity id null');

        //Assign data
        entity.created_date = dto.created_date ? dto.created_date : entity.created_date;
        entity.approved_date = dto.approved_date ? dto.approved_date : entity.approved_date;
        entity.declined_date = dto.declined_date ? dto.declined_date : entity.declined_date;
        entity.value = dto.value ? dto.value : entity.value;
        entity.cost = dto.cost ? dto.cost : entity.cost;
        entity.use_fintech = dto.use_fintech ? dto.use_fintech : entity.use_fintech;
        let employee = new Employee();
        employee.uuid = dto.employee;
        entity.employee = dto.employee ? employee : entity.employee;
        let advance_state = new AdvanceState();
        advance_state.cod = dto.state;
        entity.state = dto.state ? advance_state : entity.state;
        return entity;
    }

    async dataValidationBeforeEdit(dto: AdvanceDTO): Promise<void> {
        // Input validations for null values that are required
        // For example validate if not exists for specific(s) properties
        // Example same login, same email, same cod, same nit
    }

    async findAllByEmployeePending(employee: string): Promise<Advance[]> {
        return await this.findMany({ 
            where: { employee: { uuid: employee }, state: { cod: 'PEND' } }, 
            order: { created_date: 'DESC' }, 
        });
    }

}

/** Generated by https://github.com/VictorAndres20 code generator for database, NestJS, React */