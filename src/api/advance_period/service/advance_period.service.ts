import { Injectable } from '@nestjs/common';
import { BasicCrudService } from '../../../commons/services/crud.service';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm';
import { AdvancePeriod } from '../entity/advance_period.entity';
import { AdvancePeriodDTO } from '../entity/advance_period.dto';
import { Advance } from 'src/api/advance/entity/advance.entity';

@Injectable()
export class AdvancePeriodService extends BasicCrudService<AdvancePeriod, string, AdvancePeriodDTO>{

    constructor(
        @InjectRepository(AdvancePeriod)
        protected repo: Repository<AdvancePeriod>,
        private connection: DataSource,
    ) {super();}

    findAll(): Promise<AdvancePeriod[]> {
        return this.findMany({ 
            order: { created_date: 'DESC' },
        });
    }

    findAllByEnterprise(enterprise: number): Promise<AdvancePeriod[]> {
        return this.findMany({ 
            where: {enterprise_id: enterprise},
            order: { created_date: 'DESC' },
        });
    }

    findById(id: string): Promise<AdvancePeriod>{
        try{
            return this.findOne({where: {uuid:id}});
        } catch(err){
            throw new Error(err.message);
        }
    }

    async findPendingAdvancesByEnterprise(enterprise: number): Promise<Advance[]> {
        return await this.repo.manager.getRepository(Advance).createQueryBuilder('advance')
        .innerJoin('advance.employee', 'employee')
        .innerJoin('employee.range', 'range')
        .innerJoin('range.enterprise', 'enterprise')
        .where('advance.state = :state', {state: 'PEND'})
        .andWhere('enterprise.id = :enterprise', {enterprise})
        .getMany();
    }

    buildBaseCreation(dto: AdvancePeriodDTO): AdvancePeriod{
        //Validations data
        if(! dto) throw new Error('DTO empty');

        //Assign data
        let entity = new AdvancePeriod();
        entity.name = dto.name;
        entity.created_date = dto.created_date;
        entity.finished_date = dto.finished_date;
        entity.enterprise_id = dto.enterprise_id;
        return entity;
    }

    async dataValidationBeforeCreate(dto: AdvancePeriodDTO): Promise<void> {
        const advances = await this.findPendingAdvancesByEnterprise(dto.enterprise_id);
            
        if(advances.length) throw new Error(`Hay adelantos pendientes para esta empresa`);
    }

    buildBaseEdition(entity: AdvancePeriod, dto: AdvancePeriodDTO): AdvancePeriod{
        //Validations data
        if(! dto) throw new Error('DTO empty');
        if(! dto.uuid) throw new Error('Entity id null');

        //Assign data
        entity.name = dto.name ? dto.name : entity.name;
        entity.created_date = dto.created_date ? dto.created_date : entity.created_date;
        entity.finished_date = dto.finished_date ? dto.finished_date : entity.finished_date;
        entity.enterprise_id = dto.enterprise_id ? dto.enterprise_id : entity.enterprise_id;
        return entity;
    }

    async dataValidationBeforeEdit(dto: AdvancePeriodDTO): Promise<void> {
        // Input validations for null values that are required
        // For example validate if not exists for specific(s) properties
        // Example same login, same email, same cod, same nit
    }

    async finishAndCreate(dto: AdvancePeriodDTO): Promise<AdvancePeriod> {
        const queryRunner = this.connection.createQueryRunner();
        await queryRunner.startTransaction();
        try {
            await this.dataValidationBeforeCreate(dto);
            const finishPeriod = await this.findById(dto.period_to_finish);
            if(! finishPeriod) throw new Error('No period to finish');
            finishPeriod.finished_date = dto.finished_date;
            await queryRunner.manager.save(finishPeriod);
            const entity = this.buildBaseCreation(dto);
            const entityCreated = await queryRunner.manager.save(entity);
            await queryRunner.commitTransaction();
            return entityCreated;
        } catch (err) {
            await queryRunner.rollbackTransaction();
            throw new Error(err.message);
        } finally {
            await queryRunner.release();
        }
    }

}

/** Generated by https://github.com/VictorAndres20 code generator for database, NestJS, React */